/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * <h2><center>&copy; Copyright (c) 2023 STMicroelectronics.
 * All rights reserved.</center></h2>
 *
 * This software component is licensed by ST under BSD 3-Clause license,
 * the "License"; You may not use this file except in compliance with the
 * License. You may obtain a copy of the License at:
 *                        opensource.org/licenses/BSD-3-Clause
 *
 ******************************************************************************
 */

#if !defined(__SOFT_FP__) && defined(__ARM_FP)
#warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

#include "Scheduler.h"
#include "MY_RTOS_FIFO.h"







// =========================================================================================
// |===================================== test case 1 ======================================
// =========================================================================================

// if the task has the same priority (Round Robin)

//int task1LED,task2LED,task3LED;
//Task_ref Task1,Task2,Task3;
//
//void Task_ONE(void)
//{
//	while(1)
//	{
//		task1LED ^=1;
//	}
//}
//void Task_TWO(void)
//{
//	while(1)
//	{
//		task2LED ^=1;
//	}
//}
//void Task_THREE(void)
//{
//	while(1)
//	{
//		task3LED ^=1;
//	}
//}
//
//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	Task1.P_Task_Entry = Task_ONE ;
//	strcpy(Task1.Task_Name , "Task_1");
//	Task1.Task_Priority = 3 ;
//	Task1.Task_Size = 1024 ;
//
//	Task2.P_Task_Entry = Task_TWO ;
//	strcpy(Task2.Task_Name , "Task_2");
//	Task2.Task_Priority = 3 ;
//	Task2.Task_Size = 1024 ;
//
//	Task3.P_Task_Entry = Task_THREE ;
//	strcpy(Task3.Task_Name , "Task_3");
//	Task3.Task_Priority = 3 ;
//	Task3.Task_Size = 1024 ;
//
//
//
//	error = MYRTOS_Creat_Task(&Task1);
//	error = MYRTOS_Creat_Task(&Task2);
//	error = MYRTOS_Creat_Task(&Task3);
//
//
//
//	MYRTOS_Activate_Task(&Task1);
//	MYRTOS_Activate_Task(&Task2);
//	MYRTOS_Activate_Task(&Task3);
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}




// =========================================================================================
// |===================================== test case 2 ======================================
// =========================================================================================
// if task with highest priority should be executed now
// the other task will be in suspend status until the higher priority executed
//int task1LED,task2LED,task3LED,task4LED;
//Task_ref Task1,Task2,Task3,Task4;
//
//void Task_ONE(void)
//{
//	static int counter;
//	while(1)
//	{
//		task1LED ^=1;
//		counter ++;
//		if(counter == 100)
//		{
//			MYRTOS_Activate_Task(&Task4);
//			counter = 0;
//		}
//	}
//}
//void Task_TWO(void)
//{
//	while(1)
//	{
//		task2LED ^=1;
//	}
//}
//void Task_THREE(void)
//{
//	while(1)
//	{
//		task3LED ^=1;
//	}
//}
//
//void Task_FOUR(void)
//{
//	static int counter;
//	while(1)
//	{
//		task4LED ^=1;
//		counter ++;
//		if(counter == 0xFFF)
//		{
//			MYRTOS_Terminate_Task(&Task4);
//			counter = 0;
//		}
//	}
//
//}
//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	Task1.P_Task_Entry = Task_ONE ;
//	strcpy(Task1.Task_Name , "Task_1");
//	Task1.Task_Priority = 3 ;
//	Task1.Task_Size = 1024 ;
//
//	Task2.P_Task_Entry = Task_TWO ;
//	strcpy(Task2.Task_Name , "Task_2");
//	Task2.Task_Priority = 3 ;
//	Task2.Task_Size = 1024 ;
//
//	Task3.P_Task_Entry = Task_THREE ;
//	strcpy(Task3.Task_Name , "Task_3");
//	Task3.Task_Priority = 3 ;
//	Task3.Task_Size = 1024 ;
//
//
//	Task4.P_Task_Entry = Task_FOUR ;
//	strcpy(Task4.Task_Name , "Task_4");
//	Task4.Task_Priority = 1 ;
//	Task4.Task_Size = 1024 ;
//
//	error = MYRTOS_Creat_Task(&Task1);
//	error = MYRTOS_Creat_Task(&Task2);
//	error = MYRTOS_Creat_Task(&Task3);
//	error = MYRTOS_Creat_Task(&Task4);
//
//
//	MYRTOS_Activate_Task(&Task1);
//	MYRTOS_Activate_Task(&Task2);
//	MYRTOS_Activate_Task(&Task3);
//
//
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}


// =========================================================================================
// |===================================== test case 3 ======================================
// =========================================================================================
//if there is no any task in ready states ---> idle task will executed only
// we use instruction __asm("WFE") ; in idle task to make the processor in sleep mode until any event

//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}


// =========================================================================================
// |===================================== test case 4 ======================================
// =========================================================================================
// we will make every task work every specific period
//int task1LED,task2LED,task3LED,task4LED;
//Task_ref Task1,Task2,Task3,Task4;
//
//void Task_ONE(void)
//{
//	while(1)
//	{
//		task1LED ^=1;
//		MYRTOS_Task_Wait(100,&Task1);// run every 100 m sec
//	}
//}
//void Task_TWO(void)
//{
//	while(1)
//	{
//		task2LED ^=1;
//		MYRTOS_Task_Wait(300,&Task2);// run every 300 m sec
//	}
//}
//void Task_THREE(void)
//{
//	while(1)
//	{
//		task3LED ^=1;
//		MYRTOS_Task_Wait(500,&Task3);// run every 500 m sec
//	}
//}
//
//void Task_FOUR(void)
//{
//	while(1)
//	{
//		task4LED ^=1;
//		MYRTOS_Task_Wait(1000,&Task4);// run every 1000 m sec
//	}
//
//}
//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	Task1.P_Task_Entry = Task_ONE ;
//	strcpy(Task1.Task_Name , "Task_1");
//	Task1.Task_Priority = 3 ;
//	Task1.Task_Size = 1024 ;
//
//	Task2.P_Task_Entry = Task_TWO ;
//	strcpy(Task2.Task_Name , "Task_2");
//	Task2.Task_Priority = 3 ;
//	Task2.Task_Size = 1024 ;
//
//	Task3.P_Task_Entry = Task_THREE ;
//	strcpy(Task3.Task_Name , "Task_3");
//	Task3.Task_Priority = 3 ;
//	Task3.Task_Size = 1024 ;
//
//
//	Task4.P_Task_Entry = Task_FOUR ;
//	strcpy(Task4.Task_Name , "Task_4");
//	Task4.Task_Priority = 1 ;
//	Task4.Task_Size = 1024 ;
//
//	error = MYRTOS_Creat_Task(&Task1);
//	error = MYRTOS_Creat_Task(&Task2);
//	error = MYRTOS_Creat_Task(&Task3);
//	error = MYRTOS_Creat_Task(&Task4);
//
//
//	MYRTOS_Activate_Task(&Task1);
//	MYRTOS_Activate_Task(&Task2);
//	MYRTOS_Activate_Task(&Task3);
//	MYRTOS_Activate_Task(&Task4);
//
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}


// =========================================================================================
// |===================================== test case 5 ======================================
// =========================================================================================
// if there is a number of task with different priority (the task which has the highest priority will run first)
//int task1LED,task2LED,task3LED,task4LED;
//Task_ref Task1,Task2,Task3,Task4;
//
//void Task_ONE(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task1LED ^=1;
//		counter ++ ;
//		if(counter == 100)
//		{
//			MYRTOS_Activate_Task(&Task2);
//		}
//		if(counter == 200)
//		{
//			// shouldn't be terminated
//			// because this task activate the other tasks
//			// if this task terminated --> all the tasks will be in suspend state and the idle task will execute always
//			counter =0;
//		}
//	}
//}
//void Task_TWO(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task2LED ^=1;
//		counter ++;
//		if(counter == 100)
//		{
//			MYRTOS_Activate_Task(&Task3);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Terminate_Task(&Task2);
//			counter =0;
//		}
//	}
//}
//void Task_THREE(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task3LED ^=1;
//		counter ++;
//		if(counter == 100)
//		{
//			MYRTOS_Activate_Task(&Task4);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Terminate_Task(&Task3);
//			counter =0;
//		}
//	}
//}
//
//void Task_FOUR(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task4LED ^=1;
//		counter ++;
//		if(counter == 200)
//		{
//			MYRTOS_Terminate_Task(&Task4);
//			counter =0;
//		}
//	}
//
//}
//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	Task1.P_Task_Entry = Task_ONE ;
//	strcpy(Task1.Task_Name , "Task_1");
//	Task1.Task_Priority = 4 ;
//	Task1.Task_Size = 1024 ;
//
//	Task2.P_Task_Entry = Task_TWO ;
//	strcpy(Task2.Task_Name , "Task_2");
//	Task2.Task_Priority = 3 ;
//	Task2.Task_Size = 1024 ;
//
//	Task3.P_Task_Entry = Task_THREE ;
//	strcpy(Task3.Task_Name , "Task_3");
//	Task3.Task_Priority = 2 ;
//	Task3.Task_Size = 1024 ;
//
//
//	Task4.P_Task_Entry = Task_FOUR ;
//	strcpy(Task4.Task_Name , "Task_4");
//	Task4.Task_Priority = 1 ;
//	Task4.Task_Size = 1024 ;
//
//	error = MYRTOS_Creat_Task(&Task1);
//	error = MYRTOS_Creat_Task(&Task2);
//	error = MYRTOS_Creat_Task(&Task3);
//	error = MYRTOS_Creat_Task(&Task4);
//
//
//	// activate only task one
//	// then task one will activate the highest priority task
//	MYRTOS_Activate_Task(&Task1);
//
//
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}


// =========================================================================================
// |===================================== test case 6 ======================================
// =========================================================================================
// if any task Acquire mutex and the mutex is not valid , this task will be suspended until the mutex is valid
// there is priority inversion in this test case
//int task1LED,task2LED,task3LED,task4LED;
//Task_ref Task1,Task2,Task3,Task4;
//Mutex_ref MUTEX1;
//uint8_t payload[3] = {1,2,3};
//
//void Task_ONE(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task1LED ^=1;
//		counter ++ ;
//		if(counter == 100)
//		{
//			MYRTOS_Acquire_Mutex(&MUTEX1, &Task1);
//			MYRTOS_Activate_Task(&Task2);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Release_Mutex(&MUTEX1, &Task1);
//			counter =0;
//		}
//	}
//}
//void Task_TWO(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task2LED ^=1;
//		counter ++;
//		if(counter == 100)
//		{
//			MYRTOS_Activate_Task(&Task3);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Terminate_Task(&Task2);
//			counter =0;
//		}
//	}
//}
//void Task_THREE(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task3LED ^=1;
//		counter ++;
//		if(counter == 100)
//		{
//			MYRTOS_Activate_Task(&Task4);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Terminate_Task(&Task3);
//			counter =0;
//		}
//	}
//}
//
//void Task_FOUR(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task4LED ^=1;
//		counter ++;
//		if(counter == 20)
//		{
//			// although this task is the highest priority task , it will be suspended due to Acquire Mutex and this Mutex is not valid
//			MYRTOS_Acquire_Mutex(&MUTEX1, &Task4);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Release_Mutex(&MUTEX1, &Task4);
//			MYRTOS_Terminate_Task(&Task4);
//			counter = 0;
//		}
//	}
//
//}
//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	strcpy(MUTEX1.Mutex_Name , "MUTEX_1");
//	MUTEX1.PayLoad = payload;
//	MUTEX1.PayLoadSize = 3;
//	MUTEX1.Priority_Inheritance.Priority_Inheritance_State = PI_Disable;
//
//	Task1.P_Task_Entry = Task_ONE ;
//	strcpy(Task1.Task_Name , "Task_1");
//	Task1.Task_Priority = 4 ;
//	Task1.Task_Size = 1024 ;
//
//	Task2.P_Task_Entry = Task_TWO ;
//	strcpy(Task2.Task_Name , "Task_2");
//	Task2.Task_Priority = 3 ;
//	Task2.Task_Size = 1024 ;
//
//	Task3.P_Task_Entry = Task_THREE ;
//	strcpy(Task3.Task_Name , "Task_3");
//	Task3.Task_Priority = 2 ;
//	Task3.Task_Size = 1024 ;
//
//
//	Task4.P_Task_Entry = Task_FOUR ;
//	strcpy(Task4.Task_Name , "Task_4");
//	Task4.Task_Priority = 1 ;
//	Task4.Task_Size = 1024 ;
//
//	error = MYRTOS_Creat_Task(&Task1);
//	error = MYRTOS_Creat_Task(&Task2);
//	error = MYRTOS_Creat_Task(&Task3);
//	error = MYRTOS_Creat_Task(&Task4);
//
//
//	// activate only task one
//	// then task one will activate the highest priority task
//	MYRTOS_Activate_Task(&Task1);
//
//
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}


// =========================================================================================
// |===================================== test case 7 ======================================
// =========================================================================================
// the same previous test case but here to avoid priority inversion , we will do priority inheritance
int task1LED,task2LED,task3LED,task4LED;
Task_ref Task1,Task2,Task3,Task4;
Mutex_ref MUTEX1;
uint8_t payload[3] = {1,2,3};

void Task_ONE(void)
{
	static int counter ;
	while(1)
	{
		task1LED ^=1;
		counter ++ ;
		if(counter == 100)
		{
			MYRTOS_Acquire_Mutex(&MUTEX1, &Task1);
			MYRTOS_Activate_Task(&Task2);
		}
		if(counter == 200)
		{
			MYRTOS_Release_Mutex(&MUTEX1, &Task1);
			counter =0;
		}
	}
}
void Task_TWO(void)
{
	static int counter ;
	while(1)
	{
		task2LED ^=1;
		counter ++;
		if(counter == 100)
		{
			MYRTOS_Activate_Task(&Task3);
		}
		if(counter == 200)
		{
			MYRTOS_Terminate_Task(&Task2);
			counter =0;
		}
	}
}
void Task_THREE(void)
{
	static int counter ;
	while(1)
	{
		task3LED ^=1;
		counter ++;
		if(counter == 100)
		{
			MYRTOS_Activate_Task(&Task4);
		}
		if(counter == 200)
		{
			MYRTOS_Terminate_Task(&Task3);
			counter =0;
		}
	}
}

void Task_FOUR(void)
{
	static int counter ;
	while(1)
	{
		task4LED ^=1;
		counter ++;
		if(counter == 20)
		{
			// priority inheritance (task 1 will be highest priority until release mutes )
			MYRTOS_Acquire_Mutex(&MUTEX1, &Task4);
		}
		if(counter == 200)
		{
			MYRTOS_Release_Mutex(&MUTEX1, &Task4);
			MYRTOS_Terminate_Task(&Task4);
			counter = 0;
		}
	}

}
int main(void)
{

	MYRTOS_HW_Init();
	MYRTOS_Error_Source error ;

	if(MYRTOS_init() != MYRTOS_NO_ERROR)
	{
		while(1);
	}


	strcpy(MUTEX1.Mutex_Name , "MUTEX_1");
	MUTEX1.PayLoad = payload;
	MUTEX1.PayLoadSize = 3;
	MUTEX1.Priority_Inheritance.Priority_Inheritance_State = PI_Enable;

	Task1.P_Task_Entry = Task_ONE ;
	strcpy(Task1.Task_Name , "Task_1");
	Task1.Task_Priority = 4 ;
	Task1.Task_Size = 1024 ;

	Task2.P_Task_Entry = Task_TWO ;
	strcpy(Task2.Task_Name , "Task_2");
	Task2.Task_Priority = 3 ;
	Task2.Task_Size = 1024 ;

	Task3.P_Task_Entry = Task_THREE ;
	strcpy(Task3.Task_Name , "Task_3");
	Task3.Task_Priority = 2 ;
	Task3.Task_Size = 1024 ;


	Task4.P_Task_Entry = Task_FOUR ;
	strcpy(Task4.Task_Name , "Task_4");
	Task4.Task_Priority = 1 ;
	Task4.Task_Size = 1024 ;

	error = MYRTOS_Creat_Task(&Task1);
	error = MYRTOS_Creat_Task(&Task2);
	error = MYRTOS_Creat_Task(&Task3);
	error = MYRTOS_Creat_Task(&Task4);


	// activate only task one
	// then task one will activate the highest priority task
	MYRTOS_Activate_Task(&Task1);



	MYRTOS_Start();
	/* Loop forever */
	while(1)
	{

	}
}


// =========================================================================================
// |===================================== test case 8 ======================================
// =========================================================================================
// Dead lock
//int task1LED,task2LED,task3LED,task4LED;
//Task_ref Task1,Task2,Task3,Task4;
//Mutex_ref MUTEX1,MUTEX2;
//uint8_t payload[3] = {1,2,3};
//
//void Task_ONE(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task1LED ^=1;
//		counter ++ ;
//		if(counter == 100)
//		{
//			MYRTOS_Acquire_Mutex(&MUTEX1, &Task1);
//			MYRTOS_Activate_Task(&Task4);
//			MYRTOS_Acquire_Mutex(&MUTEX2, &Task1);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Release_Mutex(&MUTEX1, &Task1);
//			counter =0;
//		}
//	}
//}
//
//void Task_FOUR(void)
//{
//	static int counter ;
//	while(1)
//	{
//		task4LED ^=1;
//		counter ++;
//		if(counter == 20)
//		{
//			MYRTOS_Acquire_Mutex(&MUTEX2, &Task4);
//			MYRTOS_Acquire_Mutex(&MUTEX1, &Task4);
//		}
//		if(counter == 200)
//		{
//			MYRTOS_Release_Mutex(&MUTEX2, &Task4);
//			MYRTOS_Terminate_Task(&Task4);
//			counter = 0;
//		}
//	}
//
//}
//int main(void)
//{
//
//	MYRTOS_HW_Init();
//	MYRTOS_Error_Source error ;
//
//	if(MYRTOS_init() != MYRTOS_NO_ERROR)
//	{
//		while(1);
//	}
//
//
//	strcpy(MUTEX1.Mutex_Name , "MUTEX_1");
//	MUTEX1.PayLoad = payload;
//	MUTEX1.PayLoadSize = 3;
//	MUTEX1.Priority_Inheritance.Priority_Inheritance_State = PI_Disable;
//
//	strcpy(MUTEX2.Mutex_Name , "MUTEX_2");
//	MUTEX1.PayLoad = payload;
//	MUTEX1.PayLoadSize = 3;
//	MUTEX1.Priority_Inheritance.Priority_Inheritance_State = PI_Disable;
//
//	Task1.P_Task_Entry = Task_ONE ;
//	strcpy(Task1.Task_Name , "Task_1");
//	Task1.Task_Priority = 4 ;
//	Task1.Task_Size = 1024 ;
//
//
//	Task4.P_Task_Entry = Task_FOUR ;
//	strcpy(Task4.Task_Name , "Task_4");
//	Task4.Task_Priority = 1 ;
//	Task4.Task_Size = 1024 ;
//
//	error = MYRTOS_Creat_Task(&Task1);
//	error = MYRTOS_Creat_Task(&Task4);
//
//
//
//	MYRTOS_Activate_Task(&Task1);
//
//
//
//	MYRTOS_Start();
//	/* Loop forever */
//	while(1)
//	{
//
//	}
//}
//
//



// ========================================================================================
// ========================================================================================
// ========================================================================================
// ====================================== MY OWN RTOS =====================================
// ========================================================================================
// ========================================================================================

